# 클래스
공학 소프트웨어를 만드는데 가장 중요한 작업은 중요한 수학적 추상화를 식별하고 효율적으로 표현하는 것이다. 소프트웨어 개발자는 도메인 전문가와 상의하여 구성요소의 이름을 지정해야 하며, 만들어진 소프트웨어는 사용자에게도 직관적어야 한다. 클래스는 추상화를 수립하는 도구이다.


## 2. 멤버
멤버는 클래스에 정의되는 변수(member variable)와 함수(member function)이다. 멤버로 간단한 클래스를 구성해보자. 이하의 클래스는 멤버변수를 보호하고 있으며, 접근을 위한 멤버함수 getter와 setter를 제공한다.

``` cpp
class complex
{
public:     // 어디서나 접근 가능
    double get_r() { return r; }            // (여기에는 없지만) 사용빈도를 계산할 수도 있다.
    void set_r(double rnew) { r = rnew; }   // (여기에는 없지만) 입력범위를 제한할 수도 있다.
    double get_i() { return i; }
    void set_i(double inew) { i = inew; }

private:    // 클래스 내부에서만 접근 가능
    double r, i;
};
```

멤버에는 연산자 `.`로 접근한다. 클래스의 포인터가 주어지는 경우에는 `->`로 접근할 수 있다. 일단 멤버에 접근하면 일반적인 변수나 함수처럼 사용할 수 있다.

``` cpp
// 클래스로 접근
complex c;
std::cout << c.get_r() << std::endl;
```

``` cpp
// 클래스 포인터로 접근
complex* p = &c;
std::cout << (*p).get_r() << std::endl; // 포인터가 중첩될 경우 표현이 복잡해진다.
std::cout << p->get_r() << std::endl;   // 따라서 포인터는 `.`보다는 `->`로 접근한다.
```

하지만 getter와 setter가 불편한 것은 사실이다. 다음 절에서 일반적인 값 설정법을 소개한다.


## 3. 값 설정: 생성자 및 할당 연산자
### 3.1. 생성자
생성자는 클래스 개체를 초기화하는 멤버함수이다. 클래스와 이름이 같다. 클래스는 생성자가 없으면 암시적으로 디폴트 생성자를 만드는데, 문제의 소지가 있으므로 생성자는 직접 정의하기를 권장한다.

``` cpp
class class
{
public:
    complex(double rnew, double inew)    // 디폴트 생성자는 그냥 complex()를 정의할 것이다.
    : r(rnew), i(inew)       // 초기화 리스트. 명시하지 않으면 컴파일러가 모든 멤버를 적어넣는다.
    { }
}
```

생성자는 최초 생성뿐만 아니라 복사에도 사용된다. 디폴트 복사생성자는 모든 멤버변수를 복사하는데, 멤버에 포인터가 있다면 복사된 개체가 원본의 데이터에 접근하거나 동일한 메모리를 중복해제하는 문제가 발생한다. 이러한 문제만 없다면 디폴트 복사생성자의 사용을 권장한다.

``` cpp
complex z1(3, 2);   // 생성
complex z2(z1);     // 복사
```

### 3.2. 할당
동일한 개체를 생성할 때에는 복사생성자가 유용하지만, 개체를 복사할 때에는 할당연산자 `=`가 직관적이다. 이 경우에는 오버로딩을 통해 해당클래스에 적용할 할당연산자를 재정의할 수 있다.

``` cpp
complex& operator=(const complex& src)
{
    r = src.r; i = src.i;
    return *this;   // 자신을 역참조하여 반환한다.
}
```

할당연산자는 getter를 통해 멤버에 접근하거나 `friend`로 접근권한을 할당받을 수 있다.


## 4. 소멸자
소멸자는 개체를 파괴할 때 호출되는 함수이다. 생성자와는 달리 인수가 없으므로 오버로딩도 없다. 소멸자에게 기대되는 기능은 리소스를 해제하는 것이다.

``` cpp
class vector
{
public:
    ~vector()
    {
        delete[] data;  // 리소스를 해제한다.
    }

private:
    double* data;
}
```

> 애초에 리소스를 해제할 필요가 없는 스마트 포인터의 사용을 권장한다.

> 소멸자에서는 예외처리를 사용할 수 없다.
